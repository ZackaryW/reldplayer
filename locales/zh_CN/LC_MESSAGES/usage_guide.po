# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, ZackaryW
# This file is distributed under the same license as the reldplayer package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: reldplayer \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-29 01:08-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../docs/usage_guide.rst:3
msgid "core.player"
msgstr ""

#: of reldplayer.core.config.PlayerConfig:1 reldplayer.core.ctx.PlayerCtx:1
#: reldplayer.core.player.Player:1
#: reldplayer.extensions.manage_config.ManageConfig:1
#: reldplayer.extensions.manage_macro.ManageMacro:1
#: reldplayer.extensions.manage_window.ManageWindow:1
#: reldplayer.internal.model_mps.KeyboardMapping:1
#: reldplayer.internal.model_record.OperationRecord:1
msgid "Bases: :py:class:`object`"
msgstr ""

#: of reldplayer.core.player.Player:1
msgid "All in one player class for interactions"
msgstr "一个集成所有交互功能的类"

#: of reldplayer.core.player.Player.copy:1
msgid "creates a copy with identical PlayerConfig"
msgstr "创建一个具有相同PlayerConfig的副本"

#: of reldplayer.core.player.Player.select:1
msgid "used to set up the PlayerCtx.selected"
msgstr "用于设置PlayerCtx.selected"

#: of reldplayer.core.player.Player.select_actives:1
msgid "select all active windows"
msgstr "选择所有活动窗口"

#: ../../docs/usage_guide.rst:12
msgid "core.config"
msgstr "配置"

#: of reldplayer.core.config.PlayerConfigMeta:1
msgid "Bases: :py:class:`type`"
msgstr "基类：:py:class:`type`"

#: of reldplayer.core.config.PlayerConfigMeta.mro:1
msgid "Return a type's method resolution order."
msgstr "返回类型的方法解析顺序。"

#: ../../docs/usage_guide.rst:22
msgid "core.ctx"
msgstr ""

#: ../../docs/usage_guide.rst:32
msgid "extensions.console"
msgstr "扩展控制台"

#: of reldplayer.extensions.console.Console:1
msgid "Bases: :py:class:`~reldplayer.internal.iconsole.IConsole`"
msgstr "基类：:py:class:`~reldplayer.internal.iconsole.IConsole`"

#: ../../docs/usage_guide.rst:42
msgid "extensions.manage_config"
msgstr "配置管理扩展"

#: ../../docs/usage_guide.rst:52
msgid "extensions.manage_macro"
msgstr "宏管理扩展"

#: ../../docs/usage_guide.rst:62
msgid "extensions.manage_window"
msgstr "窗口管理扩展"

#: of reldplayer.extensions.manage_window.GridOrient:1
#: reldplayer.internal.model_config.LeidiansConfig:1
#: reldplayer.internal.model_mps.SMP:1
#: reldplayer.internal.model_profile_config.LeidianConfig:1
#: reldplayer.internal.model_record.RecordInfo:1
msgid "Bases: :py:class:`~typing.TypedDict`"
msgstr "基类：:py:class:`~typing.TypedDict`"

#: of reldplayer.extensions.manage_window.GridOrient.fromkeys:1
msgid "Create a new dictionary with keys from iterable and values set to value."
msgstr "创建一个新字典，键来自可迭代对象，值设置为给定值。"

#: of reldplayer.extensions.manage_window.GridOrient.get:1
#: reldplayer.extensions.manage_window.GridOrient.setdefault:3
msgid "Return the value for key if key is in the dictionary, else default."
msgstr "如果字典中有该键，则返回其值；否则返回默认值。"

#: of reldplayer.extensions.manage_window.GridOrient.pop:1
msgid ""
"If the key is not found, return the default if given; otherwise, raise a "
"KeyError."
msgstr "如果找不到键，则返回默认值（如果给定）；否则，抛出KeyError。"

#: of reldplayer.extensions.manage_window.GridOrient.popitem:1
msgid "Remove and return a (key, value) pair as a 2-tuple."
msgstr "移除并返回一个（键，值）对作为二元组。"

#: of reldplayer.extensions.manage_window.GridOrient.popitem:3
msgid ""
"Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if"
" the dict is empty."
msgstr "按LIFO（后进先出）顺序返回对。如果字典为空，则引发KeyError。"

#: of reldplayer.extensions.manage_window.GridOrient.setdefault:1
msgid "Insert key with a value of default if key is not in the dictionary."
msgstr "如果字典中没有该键，则插入带有默认值的键。"

#: of reldplayer.extensions.manage_window.GridOrient.update:1
msgid ""
"If E is present and has a .keys() method, then does:  for k in E: D[k] = "
"E[k] If E is present and lacks a .keys() method, then does:  for k, v in "
"E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]"
msgstr "如果E存在并有.keys()方法，则执行：对于E中的每个k：D[k] = E[k]；如果E存在但没有.keys()方法，则执行：对于E中的每个k, v：D[k] = v。无论哪种情况，接下来执行：对于F中的每个k：D[k] = F[k]"

#: ../../docs/usage_guide.rst:71
msgid "internal"
msgstr "内部"
